import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import { db } from '../firebaseConfig';
import { getAuth, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, onAuthStateChanged, signOut } from 'firebase/auth';
import { collection, getDocs, addDoc, serverTimestamp, GeoPoint, writeBatch, setDoc, query, where, doc, getDoc } from 'firebase/firestore';
import './StakeholderMap.css';
import AssessmentPanel from './AssessmentPanel.jsx';
import BuildingInteractionPanel from './BuildingInteractionPanel.jsx';
import { surveyConfigs } from '../surveyConfigs';
import * as turf from '@turf/turf';
import { transformGeoJSON } from '../utils/geoAffine';

// --- Floor layer IDs (keep consistent) ---
const FLOOR_SOURCE_ID = "floor-src";
const FLOOR_FILL_ID = "floor-fill";
const FLOOR_LINE_ID = "floor-line";
const FLOOR_HL_ID = "floor-highlight";

// Cache to avoid double-loading sources
const floorCache = new Map();

// Department color ramp (fallback default at end)
const deptFillMatch = [
  "match",
  ["coalesce", ["get", "Department"], ""],
  "ADMIN", "#8da0cb",
  "FACILITIES / MAINTENANCE", "#66c2a5",
  "EDUCATIONAL", "#fc8d62",
  "STORAGE / MECHANICAL", "#e78ac3",
  "", "#cccccc",
  "#cccccc"
];

// Cyan highlight for the clicked room
const highlightPaint = {
  "fill-color": "#00e5ff",
  "fill-opacity": 0.55,
  "fill-outline-color": "#00e5ff"
};

// Loader that swaps the floor plan .geojson per selection
async function loadFloorGeojson(map, url, rehighlightId, affineParams) {
  if (!map || !url) return;

  // If we already loaded this url once, reuse the data
  if (!floorCache.has(url)) {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Floor load failed: ${res.status} ${url}`);
    const geojson = await res.json();
    floorCache.set(url, geojson);
  }
  let data = floorCache.get(url);

  try {
    if (affineParams && (affineParams.tx || affineParams.ty || affineParams.angleDeg || (typeof affineParams.scale === 'number' && affineParams.scale !== 1))) {
      data = transformGeoJSON(data, affineParams);
    }
  } catch {}

  // 1) Source (create or update)
  if (map.getSource(FLOOR_SOURCE_ID)) {
    map.getSource(FLOOR_SOURCE_ID).setData(data);
  } else {
    map.addSource(FLOOR_SOURCE_ID, { type: "geojson", data, promoteId: 'RevitId' });
  }

  // 2) Fill (dept-shaded)
  if (!map.getLayer(FLOOR_FILL_ID)) {
    map.addLayer({
      id: FLOOR_FILL_ID,
      type: "fill",
      source: FLOOR_SOURCE_ID,
      paint: { "fill-color": deptFillMatch, "fill-opacity": 0.35 }
    });
  }

  // 3) Outline
  if (!map.getLayer(FLOOR_LINE_ID)) {
    map.addLayer({
      id: FLOOR_LINE_ID,
      type: "line",
      source: FLOOR_SOURCE_ID,
      paint: { "line-color": "#444", "line-width": 1 }
    });
  }

  // 4) Highlight layer (empty source filter until click)
  if (!map.getLayer(FLOOR_HL_ID)) {
    map.addLayer({
      id: FLOOR_HL_ID,
      type: "fill",
      source: FLOOR_SOURCE_ID,
      paint: highlightPaint,
      filter: ["in", ["id"], ["literal", []]] // nothing selected
    });
  }

  // Re-apply previous selection highlight for this floor if provided
  if (rehighlightId !== undefined && rehighlightId !== null) {
    try { map.setFilter(FLOOR_HL_ID, ["in", ["id"], ["literal", [rehighlightId]]]); } catch {}
  }

  // 5) Fit to floor plan (optional)
  const b = turf.bbox(data);
  if (b && isFinite(b[0])) {
    map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 40, duration: 500 });
  }
}

// Normalize any GeoJSON-ish input into a FeatureCollection for safe bbox/centroid math
function toFeatureCollection(anyGeo) {
  if (!anyGeo) return null;
  if (anyGeo.type === 'FeatureCollection') return anyGeo;
  if (anyGeo.type === 'Feature') {
    return { type: 'FeatureCollection', features: [anyGeo] };
  }
  if (anyGeo.type === 'GeometryCollection') {
    return {
      type: 'FeatureCollection',
      features: (anyGeo.geometries || []).map((g) => ({ type: 'Feature', geometry: g, properties: {} }))
    };
  }
  if (anyGeo.type && anyGeo.coordinates) {
    return { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: anyGeo, properties: {} }] };
  }
  return null;
}

// Normalize room property names across varying data sources
const normalizeRoomProps = (p = {}) => ({
  number: p.Number ?? p.number ?? p.Room ?? p['Room Number'] ?? '',
  roomType: p.Name ?? p.RoomType ?? p['Rm Type'] ?? '',
  department: p.Department ?? p.Dept ?? '',
  areaSF: p.Area_SF ?? p.Area ?? p['Area SF'] ?? null,
  revitId: p.RevitId ?? p.revitId ?? null
});

// Slug helper to compare ids like "Hurley-McDonald Hall" vs "hurley_mcdonald"
function slugifyId(s) {
  return String(s || '')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '');
}

// Fit a rooms FeatureCollection to a building feature by scaling to bbox and aligning centroids
function fitFloorplanToBuilding(roomsFC, buildingGeomOrFeature) {
  try {
    if (!roomsFC || !Array.isArray(roomsFC.features) || roomsFC.features.length === 0) return roomsFC;

    const building = (buildingGeomOrFeature?.type === 'Feature')
      ? buildingGeomOrFeature
      : (buildingGeomOrFeature?.type ? { type: 'Feature', properties: {}, geometry: buildingGeomOrFeature } : null);

    if (!building) return roomsFC;

    const cRooms = turf.centroid(roomsFC);
    const cBldg = turf.centroid(building);

    const [rxMin, ryMin, rxMax, ryMax] = turf.bbox(roomsFC);
    const [bxMin, byMin, bxMax, byMax] = turf.bbox(building);

    const rW = Math.max(1e-9, rxMax - rxMin);
    const rH = Math.max(1e-9, ryMax - ryMin);
    const bW = Math.max(1e-9, bxMax - bxMin);
    const bH = Math.max(1e-9, byMax - byMin);

    const FIT_MARGIN = 0.96; // 96% of building bbox
    const scale = Math.min(bW / rW, bH / rH) * FIT_MARGIN;

    let fitted = turf.transformScale(roomsFC, scale, { origin: cRooms });

    // translate by geodesic distance/bearing from rooms centroid to building centroid
    const distKm = turf.distance(cRooms, cBldg, { units: 'kilometers' });
    const bearing = turf.bearing(cRooms, cBldg);
    fitted = turf.transformTranslate(fitted, distKm, bearing, { units: 'kilometers' });

    return fitted;
  } catch {
    return roomsFC;
  }
}

// Extract all [lng, lat] pairs from any geometry (handles deep nesting)
function extractLngLatPairs(geom) {
  const out = [];
  function collect(c) {
    if (!c) return;
    if (typeof c[0] === 'number') out.push([c[0], c[1]]);
    else c.forEach(collect);
  }
  if (geom?.type === 'GeometryCollection') (geom.geometries || []).forEach((g) => collect(g.coordinates));
  else collect(geom?.coordinates);
  return out;
}

// Compute bbox [minX, minY, maxX, maxY] from a FeatureCollection using extractLngLatPairs
function bboxFromFC(fc) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  (fc?.features || []).forEach((f) => {
    extractLngLatPairs(f.geometry).forEach(([x, y]) => {
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    });
  });
  return [minX, minY, maxX, maxY];
}

// Base URL for assets (works locally and on GitHub Pages)
const BASE = import.meta.env.BASE_URL || '/';

/**
 * Floorplans:
 * Best option is to keep a manifest at /public/floorplans/manifest.json.
 * If the manifest can't be fetched, we fall back to this static mapping.
 * Edit the mapping below to match your local files:
 *   /public/floorplans/Hastings/<Folder>/<file>.geojson
 */
const FLOORPLANS = {
  'Hurley-McDonald Hall': {
    FL1: `${BASE}floorplans/Hastings/HurleyMcDonald/fl1.geojson`,
  },
  'Gray Center': {
    FL1: `${BASE}floorplans/Hastings/GrayCenter/fl1.geojson`,
  },
  'Morrison-Reeves Science Center': {
    FL1: `${BASE}floorplans/Hastings/MorrisonReeves/fl1.geojson`,
  },
};

const BUILDING_ALIAS = {
  'Hurley-McDonald Hall': 'hurley_mcdonald',
  'Gray Center': 'gray_center',
  'Morrison-Reeves Science Center': 'morrison_reeves',
};

// Floorplan view tuning
const FLOORPLAN_FIT_PADDING = 8;   // tighter frame around floor
const FLOORPLAN_SCALE = 1.0;       // auto-fit handles size; keep neutral here

/**
 * Unload the active single-floor source/layers (FLOOR_*).
 * Safe to call even if nothing is loaded.
 */
function unloadFloorplan(map) {
  if (!map) return;
  try {
    if (map.getLayer(FLOOR_HL_ID)) map.removeLayer(FLOOR_HL_ID);
    if (map.getLayer(FLOOR_LINE_ID)) map.removeLayer(FLOOR_LINE_ID);
    if (map.getLayer(FLOOR_FILL_ID)) map.removeLayer(FLOOR_FILL_ID);
    if (map.getSource(FLOOR_SOURCE_ID)) map.removeSource(FLOOR_SOURCE_ID);
  } catch {}
}

/**
 * Center on the current single-floor source if it exists.
 */
function centerOnCurrentFloor(map) {
  try {
    const src = map?.getSource(FLOOR_SOURCE_ID);
    const data = src?._data || src?.serialize?.()?.data;
    const fc = toFeatureCollection(data);
    if (!fc) return;
    const b = turf.bbox(fc);
    if (b && isFinite(b[0])) {
      map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 40, duration: 500 });
    }
  } catch {}
}

// Load Firestore rooms at path:
// universities/{campusId}/buildings/{buildingId}/floors/{floorId}/rooms
async function loadRooms(db, campusId, buildingId, floorId) {
  const colRef = collection(
    db,
    `universities/${campusId}/buildings/${buildingId}/floors/${floorId}/rooms`
  );
  const snap = await getDocs(colRef);
  const byId = {};
  snap.forEach((d) => {
    byId[String(d.id)] = d.data();
  });
  return byId;
}

const stakeholderConditionConfig = {
  '5': { label: '5 = Excellent condition', color: '#4CAF50' },
  '4': { label: '4 = Good condition', color: '#8BC34A' },
  '3': { label: '3 = Adequate condition', color: '#FFEB3B' },
  '2': { label: '2 = Poor condition', color: '#FF9800' },
  '1': { label: '1 = Very poor condition', color: '#F44336' }
};

const progressColors = {
  0: '#85474b',
  1: '#aed6f1',
  2: '#5dade2',
  3: '#2e86c1'
};

const defaultBuildingColor = '#85474b';

const StakeholderMap = ({ config, universityId, mode = 'public', persona }) => {
  const mapContainerRef = useRef(null);
  const mapRef = useRef(null);
  const previousSelectedBuildingId = useRef(null);
  const floorSelectionRef = useRef({}); // remember last selected room id per floor URL

  const [mapLoaded, setMapLoaded] = useState(false);
  const [interactionMode, setInteractionMode] = useState('select');
  const [showMarkers, setShowMarkers] = useState(mode === 'admin'); // Paths feature removed
  const [showHelp, setShowHelp] = useState(true);
  const [markers, setMarkers] = useState([]); // Paths feature removed
  const [buildingConditions, setBuildingConditions] = useState({});
  const [buildingAssessments, setBuildingAssessments] = useState({});
  const [selectedBuildingId, setSelectedBuildingId] = useState(null);
  const [mapTheme, setMapTheme] = useState('progress');
  const [isControlsVisible, setIsControlsVisible] = useState(true);
  const [isTechnicalPanelOpen, setIsTechnicalPanelOpen] = useState(false);

  // Auth / role
  const [authUser, setAuthUser] = useState(null);
  const [isAdminUser, setIsAdminUser] = useState(false);

  // Marker filters (admin)
  const [showStudentMarkers, setShowStudentMarkers] = useState(true);
  const [showStaffMarkers, setShowStaffMarkers] = useState(true);

  // Session-only markers (for public users adding points this session)
  const [sessionMarkers, setSessionMarkers] = useState([]);

  // Floorplans
  const roomAttrsRef = useRef({});
  const [fpManifest, setFpManifest] = useState(null);
  const [selectedBuilding, setSelectedBuilding] = useState('Hurley-McDonald Hall');
  const [selectedFloor, setSelectedFloor] = useState('FL1');
  const [buildingOptions, setBuildingOptions] = useState([]);
  const [floorOptions, setFloorOptions] = useState([]);
  const [loadedFloors, setLoadedFloors] = useState([]);
  const loadedFloorsRef = useRef([]);
  const floorUrlRef = useRef(null);

  // Affine transform tuning for static floorplans (admin tooling)
  const [affineOverrides, setAffineOverrides] = useState(() => {
    try { return JSON.parse(localStorage.getItem('floorAffine') || '{}'); }
    catch { return {}; }
  });
  useEffect(() => {
    try { localStorage.setItem('floorAffine', JSON.stringify(affineOverrides || {})); } catch {}
  }, [affineOverrides]);

  const [affineDraft, setAffineDraft] = useState({ tx: 0, ty: 0, scale: 1, angleDeg: 0, px: 0, py: 0 });
  const [nudgeEnabled, setNudgeEnabled] = useState(false);
  const [nudgeStep, setNudgeStep] = useState(0.00001); // degrees for tx/ty
  const [rotStep, setRotStep] = useState(0.5); // degrees for angle
  const [scaleStep, setScaleStep] = useState(1.01); // multiplicative factor per step
  const pivotPickActiveRef = useRef(false);
  const pivotPickHandlerRef = useRef(null);

  // Keyboard nudging: arrow keys adjust tx/ty; [ ] adjust angle; +/- adjust scale; shift = 10x, alt = 0.1x
  useEffect(() => {
    if (!nudgeEnabled) return;
    if (typeof window === 'undefined') return;

    const handler = async (e) => {
      const code = e.code || e.key;
      const mult = (e.shiftKey ? 10 : 1) * (e.altKey ? 0.1 : 1);
      const step = nudgeStep * mult;
      const rStep = rotStep * mult;
      const sFactor = Math.pow(scaleStep > 0 ? scaleStep : 1.01, mult);

      let changed = false;
      const next = { ...affineDraft };

      if (code === 'ArrowUp') { next.ty = (Number(next.ty)||0) + step; changed = true; }
      if (code === 'ArrowDown'){ next.ty = (Number(next.ty)||0) - step; changed = true; }
      if (code === 'ArrowLeft'){ next.tx = (Number(next.tx)||0) - step; changed = true; }
      if (code === 'ArrowRight'){ next.tx = (Number(next.tx)||0) + step; changed = true; }

      if (code === 'BracketLeft' || e.key === '[') { next.angleDeg = (Number(next.angleDeg)||0) - rStep; changed = true; }
      if (code === 'BracketRight' || e.key === ']') { next.angleDeg = (Number(next.angleDeg)||0) + rStep; changed = true; }

      if (code === 'Equal' || code === 'NumpadAdd' || e.key === '+') { next.scale = (Number(next.scale)||1) * sFactor; changed = true; }
      if (code === 'Minus' || code === 'NumpadSubtract' || e.key === '-') { next.scale = (Number(next.scale)||1) / sFactor; changed = true; }

      if (changed) {
        e.preventDefault();
        setAffineDraft(next);
        try {
          const curUrl = floorUrlRef.current;
          const lastSel = floorSelectionRef.current?.[curUrl];
          await loadFloorGeojson(mapRef.current, curUrl, lastSel, next);
        } catch {}
      }
    };

    window.addEventListener('keydown', handler, { passive: false });
    return () => { try { window.removeEventListener('keydown', handler); } catch {} };
  }, [nudgeEnabled, nudgeStep, rotStep, scaleStep, affineDraft]);

  // One-shot map click to set pivot (px,py)
  const startPivotPick = useCallback(() => {
    try {
      const map = mapRef.current;
      if (!map || pivotPickActiveRef.current) return;
      pivotPickActiveRef.current = true;

      const handler = async (e) => {
        try {
          const lng = e.lngLat?.lng;
          const lat = e.lngLat?.lat;
          if (Number.isFinite(lng) && Number.isFinite(lat)) {
            const next = { ...affineDraft, px: lng, py: lat };
            setAffineDraft(next);
            const curUrl = floorUrlRef.current;
            const lastSel = floorSelectionRef.current?.[curUrl];
            await loadFloorGeojson(mapRef.current, curUrl, lastSel, next);
          }
        } finally {
          try { map.off('click', handler); } catch {}
          pivotPickActiveRef.current = false;
          pivotPickHandlerRef.current = null;
        }
      };

      pivotPickHandlerRef.current = handler;
      map.on('click', handler);
    } catch {}
  }, [affineDraft]);

  const cancelPivotPick = useCallback(() => {
    try {
      const map = mapRef.current;
      if (map && pivotPickHandlerRef.current) {
        map.off('click', pivotPickHandlerRef.current);
      }
    } catch {}
    pivotPickActiveRef.current = false;
    pivotPickHandlerRef.current = null;
  }, []);

  const setPivotToSelectedCentroid = useCallback(async () => {
    try {
      const feats = config?.buildings?.features || [];
      const bf = feats.find(f => String(f?.properties?.id) === String(selectedBuildingId));
      if (!bf) { alert('No selected building to compute centroid from.'); return; }
      const c = turf.centroid(bf);
      const [lng, lat] = c?.geometry?.coordinates || [];
      if (!Number.isFinite(lng) || !Number.isFinite(lat)) return;
      const next = { ...affineDraft, px: lng, py: lat };
      setAffineDraft(next);
      const curUrl = floorUrlRef.current;
      const lastSel = floorSelectionRef.current?.[curUrl];
      await loadFloorGeojson(mapRef.current, curUrl, lastSel, next);
    } catch {}
  }, [config, selectedBuildingId, affineDraft]);

  // Snap scale so the rotated floor bbox fits inside selected building bbox (keeps pivot/tx/ty/angle)
  const [fitMargin, setFitMargin] = useState(0.96);
  const snapScaleToBuilding = useCallback(async () => {
    try {
      const curUrl = floorUrlRef.current;
      const raw = floorCache.get(curUrl);
      if (!raw) { alert('Load the floorplan first.'); return; }

      // Find a building feature for the current selectedBuilding label or slug alias
      let buildingFeature = null;
      try {
        const bFeatures = config?.buildings?.features || [];
        buildingFeature = bFeatures.find((bf) => String(bf?.properties?.id) === selectedBuilding) || null;
        if (!buildingFeature) {
          const want = slugifyId(BUILDING_ALIAS[selectedBuilding] || selectedBuilding);
          buildingFeature = bFeatures.find((bf) => slugifyId(bf?.properties?.id) === want) || null;
        }
      } catch {}
      if (!buildingFeature) { alert('Cannot find building polygon to fit.'); return; }

      const b = turf.bbox(buildingFeature);
      const bW = Math.max(1e-12, b[2] - b[0]);
      const bH = Math.max(1e-12, b[3] - b[1]);

      // Transform raw floor with current angle/pivot but unit scale and zero translation for measuring size
      const base = transformGeoJSON(toFeatureCollection(raw), {
        angleDeg: Number(affineDraft.angleDeg)||0,
        scale: 1, tx: 0, ty: 0,
        px: Number(affineDraft.px)||0, py: Number(affineDraft.py)||0
      });
      const rb = turf.bbox(base);
      const rW = Math.max(1e-12, rb[2] - rb[0]);
      const rH = Math.max(1e-12, rb[3] - rb[1]);

      const margin = Number.isFinite(fitMargin) ? fitMargin : 1;
      const newScale = Math.min(bW / rW, bH / rH) * margin;
      if (!Number.isFinite(newScale) || newScale <= 0) { alert('Failed to compute a valid scale.'); return; }

      const next = { ...affineDraft, scale: newScale };
      setAffineDraft(next);
      const lastSel = floorSelectionRef.current?.[curUrl];
      await loadFloorGeojson(mapRef.current, curUrl, lastSel, next);
    } catch (e) {
      console.warn('Snap scale failed:', e);
      alert('Snap scale failed. See console for details.');
    }
  }, [affineDraft, config, selectedBuilding, fitMargin]);

  // Snap translate so the transformed floor centroid aligns to the building centroid
  const snapTranslateToBuildingCentroid = useCallback(async () => {
    try {
      const curUrl = floorUrlRef.current;
      const raw = floorCache.get(curUrl);
      if (!raw) { alert('Load the floorplan first.'); return; }

      // Resolve building feature similar to scale snap
      let buildingFeature = null;
      try {
        const bFeatures = config?.buildings?.features || [];
        buildingFeature = bFeatures.find((bf) => String(bf?.properties?.id) === selectedBuilding) || null;
        if (!buildingFeature) {
          const want = slugifyId(BUILDING_ALIAS[selectedBuilding] || selectedBuilding);
          buildingFeature = bFeatures.find((bf) => slugifyId(bf?.properties?.id) === want) || null;
        }
      } catch {}
      if (!buildingFeature) { alert('Cannot find building polygon to compute centroid.'); return; }

      // Current fully-transformed floor (with tx/ty) to measure its centroid
      const cur = transformGeoJSON(
        toFeatureCollection(raw),
        {
          angleDeg: Number(affineDraft.angleDeg) || 0,
          scale: Number(affineDraft.scale) || 1,
          tx: Number(affineDraft.tx) || 0,
          ty: Number(affineDraft.ty) || 0,
          px: Number(affineDraft.px) || 0,
          py: Number(affineDraft.py) || 0,
        }
      );
      const cFloor = turf.centroid(cur);
      const cBuild = turf.centroid(buildingFeature);
      const [fx, fy] = cFloor?.geometry?.coordinates || [];
      const [bx, by] = cBuild?.geometry?.coordinates || [];
      if (![fx, fy, bx, by].every(Number.isFinite)) { alert('Failed to compute centroids.'); return; }

      const dx = bx - fx; const dy = by - fy;
      const next = { ...affineDraft, tx: (Number(affineDraft.tx)||0) + dx, ty: (Number(affineDraft.ty)||0) + dy };
      setAffineDraft(next);
      const lastSel = floorSelectionRef.current?.[curUrl];
      await loadFloorGeojson(mapRef.current, curUrl, lastSel, next);
    } catch (e) {
      console.warn('Snap translate failed:', e);
      alert('Snap translate failed. See console for details.');
    }
  }, [affineDraft, config, selectedBuilding]);

  // Fit (scale) to building bbox then center by aligning centroids in one step
  const fitAndCenterToBuilding = useCallback(async () => {
    try {
      const curUrl = floorUrlRef.current;
      const raw = floorCache.get(curUrl);
      if (!raw) { alert('Load the floorplan first.'); return; }

      // Resolve building feature
      let buildingFeature = null;
      try {
        const bFeatures = config?.buildings?.features || [];
        buildingFeature = bFeatures.find((bf) => String(bf?.properties?.id) === selectedBuilding) || null;
        if (!buildingFeature) {
          const want = slugifyId(BUILDING_ALIAS[selectedBuilding] || selectedBuilding);
          buildingFeature = bFeatures.find((bf) => slugifyId(bf?.properties?.id) === want) || null;
        }
      } catch {}
      if (!buildingFeature) { alert('Cannot find building polygon to fit/center.'); return; }

      const bb = turf.bbox(buildingFeature);
      const bW = Math.max(1e-12, bb[2] - bb[0]);
      const bH = Math.max(1e-12, bb[3] - bb[1]);

      const angleDeg = Number(affineDraft.angleDeg) || 0;
      const px = Number(affineDraft.px) || 0;
      const py = Number(affineDraft.py) || 0;

      // Rotate around pivot, no translate, unit scale to measure size
      const rotated = transformGeoJSON(toFeatureCollection(raw), { angleDeg, scale: 1, tx: 0, ty: 0, px, py });
      const rb = turf.bbox(rotated);
      const rW = Math.max(1e-12, rb[2] - rb[0]);
      const rH = Math.max(1e-12, rb[3] - rb[1]);

      const margin = Number.isFinite(fitMargin) ? fitMargin : 1;
      const newScale = Math.min(bW / rW, bH / rH) * margin;
      if (!Number.isFinite(newScale) || newScale <= 0) { alert('Failed to compute a valid scale.'); return; }

      // Compute centroid after applying angle + new scale (no translation yet)
      const scaled = transformGeoJSON(toFeatureCollection(raw), { angleDeg, scale: newScale, tx: 0, ty: 0, px, py });
      const cFloor = turf.centroid(scaled);
      const cBuild = turf.centroid(buildingFeature);
      const [fx, fy] = cFloor?.geometry?.coordinates || [];
      const [bx, by] = cBuild?.geometry?.coordinates || [];
      if (![fx, fy, bx, by].every(Number.isFinite)) { alert('Failed to compute centroids.'); return; }

      // Translate so centroids match
      const dx = bx - fx; const dy = by - fy;
      const next = { ...affineDraft, scale: newScale, tx: dx, ty: dy };
      setAffineDraft(next);
      const lastSel = floorSelectionRef.current?.[curUrl];
      await loadFloorGeojson(mapRef.current, curUrl, lastSel, next);
    } catch (e) {
      console.warn('Fit+Center failed:', e);
      alert('Fit + Center failed. See console for details.');
    }
  }, [affineDraft, config, selectedBuilding, fitMargin]);

  useEffect(() => {
    const base = (config?.floorplanAffine?.[selectedBuilding]?.[selectedFloor])
      || (config?.floorplanAffine?.[BUILDING_ALIAS[selectedBuilding]]?.[selectedFloor]);
    const over = affineOverrides?.[selectedBuilding]?.[selectedFloor];

    const normalizePivot = (obj) => {
      if (!obj) return {};
      if (Array.isArray(obj.pivot) && obj.pivot.length >= 2) {
        return { ...obj, px: obj.pivot[0], py: obj.pivot[1] };
      }
      return obj;
    };
    const merged = normalizePivot({ ...(base || {}), ...(over || {}) });
    const cur = { tx: 0, ty: 0, scale: 1, angleDeg: 0, px: 0, py: 0, ...(merged || {}) };
    setAffineDraft(cur);
  }, [selectedBuilding, selectedFloor, config, affineOverrides]);

  // Derive current floor URL from static map
  const floorUrl = useMemo(() => (FLOORPLANS[selectedBuilding]?.[selectedFloor] ?? null), [selectedBuilding, selectedFloor]);
  useEffect(() => { floorUrlRef.current = floorUrl; }, [floorUrl]);

  const onBuildingChange = useCallback((newBldg) => {
    setSelectedBuilding(newBldg);
    const firstFloor = Object.keys(FLOORPLANS[newBldg] ?? {})[0] || '';
    setSelectedFloor(firstFloor);
  }, []);

  const loadFloorplan = useCallback(async () => {
    if (!mapLoaded || !mapRef.current) return;
    if (!floorUrl) { console.warn('No floorplan for selection'); return; }
    try {
      const lastSel = floorSelectionRef.current?.[floorUrl];
      const baseAffine = (config?.floorplanAffine?.[selectedBuilding]?.[selectedFloor])
        || (config?.floorplanAffine?.[BUILDING_ALIAS[selectedBuilding]]?.[selectedFloor]);
      const overrideAffine = affineOverrides?.[selectedBuilding]?.[selectedFloor];
      const affine = { ...(baseAffine || {}), ...(overrideAffine || {}) };
      await loadFloorGeojson(mapRef.current, floorUrl, lastSel, affine);
    } catch (e) {
      console.error('Floorplan load failed:', e);
    }
  }, [mapLoaded, floorUrl, selectedBuilding, selectedFloor, affineOverrides]);

  const handleLoadFloorplan = useCallback(() => {
    if (selectedBuilding && selectedFloor) {
      loadFloorplan();
    }
  }, [selectedBuilding, selectedFloor, loadFloorplan]);

  // Floating panel anchor
  const [panelAnchor, setPanelAnchor] = useState(null);

  // Outdoor polygons data (for export + point-in-polygon)
  const outdoorDataRef = useRef(null);
  const [fpLoading, setFpLoading] = useState(false);
  const [fpLoadError, setFpLoadError] = useState(null);

  // Fetch floorplan manifest on load (expects public/floorplans/manifest.json)
  useEffect(() => {
    let cancelled = false;
    const loadManifest = async () => {
      if (cancelled) return;
      setFpLoading(true);
      setFpLoadError(null);
      try {
        const base = import.meta.env.BASE_URL || '/';
        const url = `${base}floorplans/manifest.json`;
        const res = await fetch(url);
        if (!res.ok) {
          console.warn('Floorplan manifest fetch failed:', url, res.status);
          if (!cancelled) setFpLoadError('Failed to load floorplans');
          return;
        }
        const data = await res.json();
        if (cancelled) return;
        setFpManifest(data);
        // Optionally set defaults if empty
        if (!selectedBuilding && Array.isArray(data?.buildings) && data.buildings.length) {
          setSelectedBuilding(data.buildings[0].id);
        }
        if (!selectedFloor && data?.floorsByBuilding) {
          const b = (!selectedBuilding && Array.isArray(data?.buildings) && data.buildings[0]?.id) ? data.buildings[0].id : selectedBuilding;
          const fls = data.floorsByBuilding?.[b] || [];
          if (fls.length) setSelectedFloor(fls[0].id);
        }
      } catch (e) {
        console.warn('Failed to load floorplan manifest:', e);
        if (!cancelled) setFpLoadError('Failed to load floorplans');
      } finally {
        if (!cancelled) setFpLoading(false);
      }
    };
    loadManifest();
    return () => { cancelled = true; };
  }, [universityId]);

  if (!universityId) { return <div>Loading University...</div>; }

  // Collections
  const markersCollection = useMemo(() => collection(db, 'universities', universityId, 'markers'), [universityId]);
  // Paths collection removed
  const conditionsCollection = useMemo(() => collection(db, 'universities', universityId, 'buildingConditions'), [universityId]);
  const assessmentsCollection = useMemo(() => collection(db, 'universities', universityId, 'buildingAssessments'), [universityId]);
  const drawingEntriesCollection = useMemo(() => collection(db, 'universities', universityId, 'drawingEntries'), [universityId]);

  // Marker sets
  const filteredMarkers = useMemo(() => {
    if (mode !== 'admin') return markers;
    return markers.filter((m) => {
      const p = (m.persona || '').toLowerCase();
      if (p.includes('student')) return showStudentMarkers;
      if (p.includes('staff') || p.includes('faculty')) return showStaffMarkers;
      return true; // keep admin/legacy visible
    });
  }, [markers, showStudentMarkers, showStaffMarkers, mode]);

  const markerTypes = useMemo(() => {
    if (mode === 'admin') return { ...surveyConfigs.student, ...surveyConfigs.staff };
    return surveyConfigs[persona] || surveyConfigs.default;
  }, [persona, mode]);

  // ---------- Auth ----------
  useEffect(() => {
    const auth = getAuth();
    getRedirectResult(auth).catch(() => {});
    const unsub = onAuthStateChanged(auth, async (user) => {
      setAuthUser(user || null);
      if (!user) {
        setIsAdminUser(false);
        return;
      }
      try {
        const roleSnap = await getDoc(doc(db, 'universities', universityId, 'roles', user.uid));
        setIsAdminUser(!!roleSnap.exists() && roleSnap.data()?.role === 'admin');
      } catch {
        setIsAdminUser(false);
      }
    });
    return () => unsub();
  }, [universityId]);

  // ---------- Load building options ----------
  useEffect(() => {
    if (!universityId) return;
    (async () => {
      try {
        // Try Firestore first
        const bCol = collection(db, 'universities', universityId, 'buildings');
        const bSnap = await getDocs(bCol);
        if (!bSnap.empty) {
          const opts = bSnap.docs.map(d => ({ id: d.id, name: d.data()?.name || d.id }));
          setBuildingOptions(opts);
          // If nothing is selected yet, default to the first
          if (!selectedBuilding && opts.length) setSelectedBuilding(opts[0].id);
          return;
        }
        // Fallback to local manifest if Firestore empty
        const base = import.meta.env.BASE_URL || '/';
        const res = await fetch(`${base}floorplans/manifest.json`);
        if (res.ok) {
          const m = await res.json(); // { buildings: { [id]: { name, floors: [...] } } }
          const opts = Object.entries(m.buildings || {}).map(([id, v]) => ({ id, name: v?.name || id }));
          setBuildingOptions(opts);
          if (!selectedBuilding && opts.length) setSelectedBuilding(opts[0].id);
        }
      } catch (e) {
        console.warn('Building options load failed:', e);
      }
    })();
  }, [universityId]);

  // ---------- Load floors when building changes ----------
  useEffect(() => {
    if (!universityId || !selectedBuilding) {
      setFloorOptions([]);
      return;
    }
    (async () => {
      try {
        // Try Firestore floors
        const fCol = collection(db, 'universities', universityId, 'buildings', selectedBuilding, 'floors');
        const fSnap = await getDocs(fCol);
        if (!fSnap.empty) {
          const floors = fSnap.docs
            .map(d => ({ id: d.id, name: d.data()?.name || d.id }))
            // numeric-aware sort
            .sort((a, b) => String(a.id).localeCompare(String(b.id), undefined, { numeric: true }));
          setFloorOptions(floors);
          if (!selectedFloor && floors.length) setSelectedFloor(floors[0].id);
          return;
        }
        // Fallback to local manifest
        const base = import.meta.env.BASE_URL || '/';
        const res = await fetch(`${base}floorplans/manifest.json`);
        if (res.ok) {
          const m = await res.json();
          const floors = (m.buildings?.[selectedBuilding]?.floors || [])
            .map(id => ({ id, name: String(id) }));
          setFloorOptions(floors);
          if (!selectedFloor && floors.length) setSelectedFloor(floors[0].id);
        }
      } catch (e) {
        console.warn('Floor options load failed:', e);
      }
    })();
  }, [universityId, selectedBuilding]);

  // ---------- Map init ----------
  useEffect(() => {
    if (mapRef.current || !mapContainerRef.current || !config) return;

    const __token = import.meta.env.VITE_MAPBOX_TOKEN || import.meta.env.VITE_MAPBOX_ACCESS_TOKEN || import.meta.env.REACT_APP_MAPBOX_ACCESS_TOKEN;
    mapboxgl.accessToken = __token;
    try { mapboxgl.setTelemetry(false); } catch {}
    if (!mapboxgl.accessToken) {
      console.warn('Mapbox token missing. Set VITE_MAPBOX_TOKEN or VITE_MAPBOX_ACCESS_TOKEN.');
    }

    // TEMP: hard-coded safe center (Hastings campus) and zoom
    const FALLBACK_CENTER = [-98.3739, 40.5939]; // [lng, lat]
    const FALLBACK_ZOOM = 16;

    // Determine initial center/zoom robustly
    let initialCenter = FALLBACK_CENTER;
    let initialZoom = FALLBACK_ZOOM;

    // Prefer explicit zoom from config if valid
    if (config?.zoom !== undefined) {
      const z = typeof config.zoom === 'string' ? parseFloat(config.zoom) : config.zoom;
      if (!isNaN(z)) initialZoom = z;
    }

    // If you have center in your config as numbers or strings
    if (config?.mapCenter && Array.isArray(config.mapCenter) && config.mapCenter.length === 2) {
      const [lng, lat] = config.mapCenter;
      const lngNum = typeof lng === 'string' ? parseFloat(lng) : lng;
      const latNum = typeof lat === 'string' ? parseFloat(lat) : lat;
      if (!isNaN(lngNum) && !isNaN(latNum)) { initialCenter = [lngNum, latNum]; }
    } else if (config?.lng !== undefined && config?.lat !== undefined) {
      const lngNum = typeof config.lng === 'string' ? parseFloat(config.lng) : config.lng;
      const latNum = typeof config.lat === 'string' ? parseFloat(config.lat) : config.lat;
      if (!isNaN(lngNum) && !isNaN(latNum)) { initialCenter = [lngNum, latNum]; }
    }

    // If you compute from boundary, protect it (boundary may be GeometryCollection)
    if (!config?.mapCenter && config?.boundary) {
      try {
        const boundaryFC = toFeatureCollection(config.boundary);
        if (boundaryFC?.features?.length) {
          const [minX, minY, maxX, maxY] = bboxFromFC(boundaryFC);
          const cx = (minX + maxX) / 2;
          const cy = (minY + maxY) / 2;
          if (!isNaN(cx) && !isNaN(cy)) initialCenter = [cx, cy];
        }
      } catch (e) {
        console.warn('Boundary center failed, using fallback', e);
      }
    }

    const el = mapContainerRef.current;
    const hasSize = () => {
      const r = el.getBoundingClientRect();
      return r.width > 0 && r.height > 0;
    };

    let ro;
    let rafId;
    let onResize;

    const init = () => {
      if (mapRef.current) return; // avoid double init
      const el = mapContainerRef.current;
      if (!el) { console.warn('No map container element yet.'); return; }

      // 1) Log style/token to sanity-check
      const styleUrl = (config && config.style) || 'mapbox://styles/mapbox/streets-v12';
      console.log('Mapbox token length:', (mapboxgl.accessToken || '').length);
      console.log('Using style:', styleUrl);

      // 2) Construct map in a try/catch, and guard before using it
      let mapInstance = null;
      try {
        mapInstance = new mapboxgl.Map({
          container: el,
          style: styleUrl,
          center: initialCenter, // e.g. [-98.3739, 40.5939]
          zoom: initialZoom, // e.g. 16
          attributionControl: false // (temporarily omit pitch/bearing until we’re stable)
        });
      } catch (e) {
        console.error('Map constructor failed:', e);
        return; // don’t proceed if we didn’t get a map
      }
      if (!mapInstance) { console.error('Map was not created (mapInstance is falsy).'); return; }

      // 3) Only now stash & add controls
      mapRef.current = mapInstance;
      try {
        mapInstance.addControl(new mapboxgl.NavigationControl(), 'top-right');
        // mapInstance.addControl(new mapboxgl.FullscreenControl());
      } catch (e) { console.warn('Adding controls failed:', e); }

      // 4) Load/resize safely
      mapInstance.once('load', () => {
        setMapLoaded(true);
        try { mapInstance.resize(); } catch {}
        // Optional fitBounds from boundary (already robust in your code)
        try {
          const boundaryFC = toFeatureCollection(config?.boundary);
          if (boundaryFC?.features?.length) {
            const [minX, minY, maxX, maxY] = bboxFromFC(boundaryFC);
            if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)) {
              mapInstance.fitBounds([[minX, minY], [maxX, maxY]], { padding: 40, duration: 0 });
            }
          }
        } catch (e) { console.warn('fitBounds from boundary failed:', e); }
      });
    };

    if (hasSize()) { init(); }
    else {
      // Wait for the element to get a size, then init once
      try {
        ro = new ResizeObserver(() => {
          if (hasSize()) {
            try { ro.disconnect(); } catch {}
            ro = undefined;
            init();
          }
        });
        ro.observe(el);
      } catch {}
      rafId = requestAnimationFrame(() => {
        if (hasSize()) {
          if (ro) { try { ro.disconnect(); } catch {} ro = undefined; }
          init();
        }
      });
    }

    return () => {
      if (rafId) cancelAnimationFrame(rafId);
      if (ro) { try { ro.disconnect(); } catch {} }
      if (onResize) { try { window.removeEventListener('resize', onResize); } catch {} }
      if (mapRef.current) { try { mapRef.current.remove(); } catch {} mapRef.current = null; }
    };
  }, [config]);

  // ---------- Load data (markers/assessments/conditions) ----------
  useEffect(() => {
    (async () => {
      try {
        // Markers
        let markersQuery;
        if (mode === 'admin') {
          markersQuery = query(markersCollection);
        } else {
          markersQuery = query(markersCollection, where('persona', '==', persona));
        }
        const markerSnap = await getDocs(markersQuery);
        setMarkers(
          markerSnap.docs.map((d) => ({ id: d.id, ...d.data(), coordinates: [d.data().coordinates.longitude, d.data().coordinates.latitude] }))
        );

        if (mode !== 'admin') {
          setBuildingConditions({});
          setBuildingAssessments({});
          return;
        }

        // Admin loads conditions and assessments
        const [condSnap, assessmentSnap] = await Promise.all([
          getDocs(conditionsCollection),
          getDocs(assessmentsCollection)
        ]);

        const condData = {};
        condSnap.forEach((d) => {
          const id = d.data().originalId || d.id.replace(/__/g, '/');
          condData[id] = d.data().condition;
        });
        setBuildingConditions(condData);

        const assessmentData = {};
        assessmentSnap.forEach((docx) => {
          const key = docx.data().originalId || docx.id.replace(/__/g, '/');
          assessmentData[key] = docx.data();
        });
        setBuildingAssessments(assessmentData);
      } catch (err) {
        console.error('Failed to fetch data:', err);
        if (mode === 'admin') {
          setBuildingConditions({});
          setBuildingAssessments({});
        }
      }
    })();
  }, [mode, universityId, persona, markersCollection, conditionsCollection, assessmentsCollection]);

  // Keep floorplan building input in sync with map selection (convenience)
  useEffect(() => {
    if (selectedBuildingId && selectedBuilding !== selectedBuildingId) {
      setSelectedBuilding(selectedBuildingId);
    }
  }, [selectedBuildingId]);

  // ---------- Base layers + Outdoor polygons ----------
  useEffect(() => {
    if (!mapLoaded || !mapRef.current || !config) return;
    const map = mapRef.current;

    // Buildings
    if (!map.getSource('buildings')) {
      map.addSource('buildings', { type: 'geojson', data: config.buildings, promoteId: 'id' });
      map.addLayer({
        id: 'buildings-layer',
        type: 'fill-extrusion',
        source: 'buildings',
        paint: {
          'fill-extrusion-color': defaultBuildingColor,
          'fill-extrusion-height': 15,
          'fill-extrusion-opacity': 0.7
        }
      });
      map.addLayer({
        id: 'buildings-outline',
        type: 'line',
        source: 'buildings',
        paint: {
          'line-color': '#007bff',
          'line-width': 2.5,
          'line-opacity': ['case', ['boolean', ['feature-state', 'selected'], false], 1, 0]
        }
      });
    }

    // Boundary
    if (config.boundary && !map.getSource('boundary')) {
      const boundaryFC = toFeatureCollection(config.boundary);
      if (boundaryFC) {
        map.addSource('boundary', { type: 'geojson', data: boundaryFC });
        map.addLayer({
          id: 'boundary-layer',
          type: 'line',
          source: 'boundary',
          paint: { 'line-color': '#a9040e', 'line-width': 3, 'line-dasharray': [2, 2] }
        });
      } else {
        console.warn('Boundary provided but could not normalize to FeatureCollection.');
      }
    }
    // Outdoor polygons disabled
  }, [mapLoaded, config]);

  // ---------- UI: building selection state ----------
  useEffect(() => {
    if (!mapLoaded || !mapRef.current) return;
    const map = mapRef.current;

    if (mode !== 'admin' && selectedBuildingId) setSelectedBuildingId(null);

    if (previousSelectedBuildingId.current) {
      map.setFeatureState({ source: 'buildings', id: previousSelectedBuildingId.current }, { selected: false });
    }
    if (selectedBuildingId && mode === 'admin') {
      map.setFeatureState({ source: 'buildings', id: selectedBuildingId }, { selected: true });
    }
    previousSelectedBuildingId.current = selectedBuildingId;
  }, [selectedBuildingId, mapLoaded, mode]);

  // ---------- Render markers ----------
  useEffect(() => {
    if (!mapLoaded || !mapRef.current) return;
    const map = mapRef.current;

    // remove existing DOM markers
    map.getCanvas().parentElement
      .querySelectorAll('.custom-mapbox-marker')
      .forEach((el) => el.remove());

    const markersToDraw = mode === 'admin' ? (showMarkers ? filteredMarkers : []) : sessionMarkers;
    markersToDraw.forEach((m) => {
      const el = document.createElement('div');
      el.className = 'custom-marker custom-mapbox-marker';
      el.style.backgroundColor = markerTypes[m.type] || '#9E9E9E';
      new mapboxgl.Marker(el)
        .setLngLat(m.coordinates)
        .setPopup(new mapboxgl.Popup({ offset: 25 }).setText(m.comment || m.type))
        .addTo(map);
    });
  }, [filteredMarkers, sessionMarkers, markerTypes, mapLoaded, mode, showMarkers]);

  // ---------- Recolor buildings based on theme ----------
  useEffect(() => {
    if (!mapLoaded || !mapRef.current || !mapRef.current.getSource('buildings')) return;
    const map = mapRef.current;

    const matchExpr = ['match', ['get', 'id']];
    let hasEntries = false;

    if (mode === 'admin' && mapTheme === 'progress' && Object.keys(buildingAssessments).length > 0) {
      Object.entries(buildingAssessments).forEach(([buildingId, assessment]) => {
        let completedSections = 0;
        if (assessment.scores?.architecture && Object.values(assessment.scores.architecture).some((s) => s > 0)) completedSections++;
        if (assessment.scores?.engineering && Object.values(assessment.scores.engineering).some((s) => s > 0)) completedSections++;
        if (assessment.scores?.functionality && Object.values(assessment.scores.functionality).some((s) => s > 0)) completedSections++;
        matchExpr.push(assessment.originalId || buildingId, progressColors[completedSections]);
        hasEntries = true;
      });
    } else if (mode === 'admin' && mapTheme === 'stakeholder' && Object.keys(buildingConditions).length > 0) {
      Object.entries(buildingConditions).forEach(([id, conditionValue]) => {
        const conditionData = stakeholderConditionConfig[conditionValue];
        if (conditionData) {
          matchExpr.push(id, conditionData.color);
          hasEntries = true;
        }
      });
    }
    matchExpr.push(defaultBuildingColor);

    if (hasEntries) {
      map.setPaintProperty('buildings-layer', 'fill-extrusion-color', matchExpr);
    } else {
      map.setPaintProperty('buildings-layer', 'fill-extrusion-color', defaultBuildingColor);
    }
  }, [buildingConditions, buildingAssessments, mapLoaded, mode, mapTheme]);

  // ---------- Map click handlers ----------
  const showMarkerPopup = useCallback((lngLat) => {
    if (!mapRef.current) return;
    const popupNode = document.createElement('div');
    popupNode.className = 'marker-prompt-popup';
    popupNode.innerHTML = `
      <h4>Add a Marker</h4>
      <select id="marker-type">
        ${Object.keys(markerTypes).map((t) => `<option value="${t}">${t}</option>`).join('')}
      </select>
      <textarea id="marker-comment" placeholder="Optional comment..."></textarea>
      <div class="button-group">
        <button id="confirm-marker">Add</button>
        <button id="cancel-marker">Cancel</button>
      </div>`;

    const popup = new mapboxgl.Popup({ closeOnClick: false, maxWidth: '280px' })
      .setDOMContent(popupNode)
      .setLngLat(lngLat)
      .addTo(mapRef.current);

    popupNode.querySelector('#confirm-marker').addEventListener('click', async () => {
      const type = popupNode.querySelector('#marker-type').value;
      const comment = popupNode.querySelector('#marker-comment').value.trim();
      const markerData = {
        coordinates: new GeoPoint(lngLat.lat, lngLat.lng),
        type,
        comment,
        persona: persona || 'admin',
        createdAt: serverTimestamp()
      };
      const docRef = await addDoc(markersCollection, markerData);
      const newMarker = { ...markerData, id: docRef.id, coordinates: [lngLat.lng, lngLat.lat] };
      setMarkers((prev) => [...prev, newMarker]);
      setSessionMarkers((prev) => [...prev, newMarker]); // show immediately for public
      popup.remove();
    });
    popupNode.querySelector('#cancel-marker').addEventListener('click', () => popup.remove());
  }, [markerTypes, markersCollection, persona]);

  // ---------- Floor click: popup + cyan highlight ----------
  useEffect(() => {
    if (!mapLoaded || !mapRef.current) return;
    const map = mapRef.current;

    const onFloorClick = (e) => {
      const f = e.features && e.features[0];
      if (!f) return;

      const selectedId = f.id != null ? f.id : f.properties?.RevitId;
      try { map.setFilter(FLOOR_HL_ID, ["in", ["id"], ["literal", [selectedId]]]); } catch {}

      // Remember selection for this floor URL to re-highlight after reloads
      if (floorUrl) {
        if (!floorSelectionRef.current) floorSelectionRef.current = {};
        floorSelectionRef.current[floorUrl] = selectedId;
      }

      const p = f.properties || {};
      const html = `
        <div style="min-width:220px">
          <div style="font-weight:600;margin-bottom:4px;">Room ${p.Number || "—"}</div>
          <div><b>Type:</b> ${p.Name || "—"}</div>
          <div><b>Department:</b> ${p.Department || "—"}</div>
          <div><b>Area (SF):</b> ${p.Area_SF || "—"}</div>
          ${p.Floor ? `<div><b>Floor:</b> ${p.Floor}</div>` : ""}
          ${p.Occupant ? `<div><b>Occupant:</b> ${p.Occupant}</div>` : ""}
          ${p.Comments ? `<div><b>Comments:</b> ${p.Comments}</div>` : ""}
        </div>`;

      new mapboxgl.Popup({ closeButton: true, offset: 12 })
        .setLngLat(e.lngLat)
        .setHTML(html)
        .addTo(map);
    };

    const onEnter = () => { try { map.getCanvas().style.cursor = 'pointer'; } catch {} };
    const onLeave = () => { try { map.getCanvas().style.cursor = ''; } catch {} };

    map.on('click', FLOOR_FILL_ID, onFloorClick);
    map.on('mouseenter', FLOOR_FILL_ID, onEnter);
    map.on('mouseleave', FLOOR_FILL_ID, onLeave);

    return () => {
      map.off('click', FLOOR_FILL_ID, onFloorClick);
      map.off('mouseenter', FLOOR_FILL_ID, onEnter);
      map.off('mouseleave', FLOOR_FILL_ID, onLeave);
    };
  }, [mapLoaded, floorUrl]);

  // Path creation removed
  useEffect(() => {
    if (!mapLoaded || !mapRef.current) return;
    const map = mapRef.current;

    const handleMapClick = (e) => {
      if (e.originalEvent.target.closest('.custom-marker')) return;

      if (interactionMode === 'select' && mode === 'admin') {
        // If any floorplan is active, do not process building selection
        let floorplanActive = false;
        try {
          const floorFillLayers = [
            ...((loadedFloors || []).map((srcId) => `${srcId}-fill`)),
            ...(map.getLayer(FLOOR_FILL_ID) ? [FLOOR_FILL_ID] : [])
          ].filter((lid) => map.getLayer(lid));
          if (floorFillLayers.length) {
            floorplanActive = true;
            const floorFeatures = map.queryRenderedFeatures(e.point, { layers: floorFillLayers });
            if (floorFeatures && floorFeatures.length > 0) { return; /* handled by per-floor click handlers */ }
          }
        } catch {}

        if (!floorplanActive) {
          const features = map.queryRenderedFeatures(e.point, { layers: ['buildings-layer'] });
          if (features.length > 0) {
            setSelectedBuildingId(features[0].properties.id);
            setIsTechnicalPanelOpen(false);
            const pt = map.project(e.lngLat);
            setPanelAnchor({ x: pt.x, y: pt.y });
            return;
          }
        }
      }

      setSelectedBuildingId(null);
      setPanelAnchor(null);
      showMarkerPopup(e.lngLat);
    };

    map.on('click', handleMapClick);
    return () => { map.off('click', handleMapClick); };
  }, [mapLoaded, mode, interactionMode, showMarkerPopup, loadedFloors]);

  // ---------- Mutations ----------
  const handleAssessmentSave = useCallback(async (updated) => {
    if (!isAdminUser) { alert('Please sign in as an admin.'); return; }
    const id = updated.originalId;
    if (!id) { console.error('Cannot save assessment: missing originalId.'); return; }
    const docRef = doc(assessmentsCollection, id.replace(/\//g, '__'));
    await setDoc(docRef, updated, { merge: true });
    setBuildingAssessments((prev) => ({ ...prev, [id]: updated }));
  }, [assessmentsCollection, isAdminUser]);

  const handleConditionSave = async (buildingId, newCondition) => {
    if (!isAdminUser) { alert('Please sign in as an admin.'); return; }
    try {
      const docRef = doc(conditionsCollection, buildingId.replace(/\//g, '__'));
      await setDoc(docRef, { condition: newCondition, originalId: buildingId }, { merge: true });
      setBuildingConditions((prev) => ({ ...prev, [buildingId]: newCondition }));

      // Fast recolor
      const map = mapRef.current;
      if (map && map.getSource('buildings')) {
        const cfg = { '5': '#4CAF50', '4': '#8BC34A', '3': '#FFEB3B', '2': '#FF9800', '1': '#F44336' };
        const merged = { ...(buildingConditions || {}), [buildingId]: newCondition };
        const expr = ['match', ['get', 'id']];
        Object.entries(merged).forEach(([id, cond]) => { if (cfg[String(cond)]) expr.push(id, cfg[String(cond)]); });
        expr.push(defaultBuildingColor);
        map.setPaintProperty('buildings-layer', 'fill-extrusion-color', expr);
      }
    } catch (err) {
      console.error('Failed to save stakeholder condition:', err);
      alert('Save failed. Are you signed in as an admin and do rules allow writes?');
    }
  };

  // --- NEW: Load floorplan and room data from Firestore ---
  const loadBuildingFloorFromFirestore = async (buildingId, floorId, overrideUrl) => {
    try {
      // Path: universities/hastings/buildings/{buildingId}/floors/{floorId}
      const floorDocRef = doc(db, 'universities', universityId, 'buildings', buildingId, 'floors', floorId);
      const floorSnap = await getDoc(floorDocRef);
      const floorData = floorSnap.exists() ? floorSnap.data() : null;

      // Get the GeoJSON floorplan URL: prefer overrideUrl, else Firestore url
      const base = import.meta.env.BASE_URL || '/';
      let geoUrl = overrideUrl || '';
      if (!geoUrl) {
        const rawUrl = floorData?.url || '';
        geoUrl = rawUrl ? (rawUrl.startsWith('http') ? rawUrl : base + String(rawUrl).replace(/^\/+/, '')) : '';
      }
      if (!geoUrl) { console.warn('No floorplan URL available for:', buildingId, floorId); return; }
      console.log('Loading floorplan from:', geoUrl);

      // Add the GeoJSON source/layers to the map
      const map = mapRef.current;
      if (!map || !geoUrl) return;
      const sourceId = `${buildingId}-${floorId}-rooms`;

      // Cleanup previous layer/source and event handlers for this sourceId
      try {
        const prev = (loadedFloorsRef.current || {})[sourceId];
        if (prev && prev.onClick) { map.off('click', `${sourceId}-fill`, prev.onClick); }
        if (prev && prev.onMouseMove) { map.off('mousemove', `${sourceId}-fill`, prev.onMouseMove); }
        if (prev && prev.onMouseLeave) { map.off('mouseleave', `${sourceId}-fill`, prev.onMouseLeave); }
      } catch {}
      if (map.getLayer(`${sourceId}-hover`)) map.removeLayer(`${sourceId}-hover`);
      if (map.getLayer(`${sourceId}-labels`)) map.removeLayer(`${sourceId}-labels`);
      if (map.getLayer(`${sourceId}-fill`)) map.removeLayer(`${sourceId}-fill`);
      if (map.getLayer(`${sourceId}-outline`)) map.removeLayer(`${sourceId}-outline`);
      if (map.getSource(sourceId)) map.removeSource(sourceId);

      // Fetch and normalize the floor GeoJSON before adding the source
      let floorFC = null;
      try {
        let rawGeo = null;
        if (typeof geoUrl === 'string') {
          const resp = await fetch(geoUrl);
          rawGeo = await resp.json();
        } else if (geoUrl && typeof geoUrl === 'object') {
          rawGeo = geoUrl;
        }
        const asFC = toFeatureCollection(rawGeo);
        let workFC = asFC;
        try {
          const affine = (config?.floorplanAffine?.[selectedBuilding]?.[floorId]) || (config?.floorplanAffine?.[buildingId]?.[floorId]);
          if (affine) workFC = transformGeoJSON(asFC, affine);
        } catch {}
        if (workFC?.features) {
          workFC.features = workFC.features.map((f) => ({
            ...f, properties: { ...(f.properties || {}), ...normalizeRoomProps(f.properties) }
          }));
          // Attempt to auto-fit rooms to selected building footprint
          let buildingFeature = null;
          try {
            const bFeatures = config?.buildings?.features || [];
            // Prefer exact match on selectedBuilding label
            buildingFeature = bFeatures.find((bf) => String(bf?.properties?.id) === selectedBuilding) || null;
            if (!buildingFeature) {
              // Fallback: slug-compare against buildingId param (e.g., hurley_mcdonald)
              const want = slugifyId(buildingId);
              buildingFeature = bFeatures.find((bf) => slugifyId(bf?.properties?.id) === want) || null;
            }
          } catch {}
          floorFC = buildingFeature ? fitFloorplanToBuilding(workFC, buildingFeature) : workFC;
        }
      } catch {}

      // Use promoteId so we can address features directly by their RevitId
      map.addSource(sourceId, { type: 'geojson', data: floorFC || geoUrl, promoteId: 'RevitId' });

      // Ensure floorplan sits above building fill by inserting before building outline layer
      const beforeBuildingOutline = map.getLayer('buildings-outline') ? 'buildings-outline' : undefined;
      map.addLayer({
        id: `${sourceId}-fill`,
        type: 'fill',
        source: sourceId,
        paint: {
          'fill-color': [
            'case',
            ['boolean', ['feature-state', 'selected'], false],
            '#00E5FF',
            '#FFB300'
          ],
          'fill-opacity': 0.55
        }
      }, beforeBuildingOutline);
      map.addLayer({
        id: `${sourceId}-outline`,
        type: 'line',
        source: sourceId,
        paint: { 'line-color': '#5a3a00', 'line-width': ['interpolate', ['linear'], ['zoom'], 16, 0.6, 20, 2.0] }
      }, beforeBuildingOutline);

      // Add room labels above the fill (but below the outline)
      if (!map.getLayer(`${sourceId}-labels`)) {
        map.addLayer(
          {
            id: `${sourceId}-labels`,
            type: 'symbol',
            source: sourceId,
            layout: {
              'text-field': ['get', 'number'],
              'text-size': ['interpolate', ['linear'], ['zoom'], 16, 10, 20, 16],
              'text-allow-overlap': false,
              'text-padding': 2,
              'text-font': ['Open Sans Semibold','Arial Unicode MS Bold'],
              'symbol-z-order': 'auto'
            },
            paint: { 'text-halo-color': '#ffffff', 'text-halo-width': 1.2, 'text-color': '#2c2c2c' }
          },
          `${sourceId}-outline`
        );
      }

      // Ensure paint properties reflect crisper floorplan styling
      try {
        map.setPaintProperty(`${sourceId}-fill`, 'fill-opacity', 0.35);
        map.setPaintProperty(`${sourceId}-fill`, 'fill-color', '#FFB300');
        map.setPaintProperty(`${sourceId}-outline`, 'line-width', 1.5);
      } catch {}

      // Auto-zoom to the floor the first time it's loaded
      try {
        const prevMeta = (loadedFloorsRef.current || {})[sourceId];
        let didFit = !!prevMeta?.didFit;
        if (!didFit) {
          let fc = floorFC;
          if (!fc && typeof geoUrl === 'string') {
            try {
              const resp = await fetch(geoUrl);
              const gj = await resp.json();
              fc = toFeatureCollection(gj);
            } catch {}
          }
          if (fc) {
            const [minX, minY, maxX, maxY] = bboxFromFC(fc);
            if ([minX, minY, maxX, maxY].every(Number.isFinite)) {
              map.fitBounds([[minX, minY], [maxX, maxY]], {
                padding: { left: 330, right: 20, top: 20, bottom: 220 },
                duration: 400
              });
            }
            // Optionally scale the floor geometry for readability
            if (typeof FLOORPLAN_SCALE === 'number' && FLOORPLAN_SCALE !== 1) {
              try {
                const scaled = turf.transformScale(fc, FLOORPLAN_SCALE);
                const src = map.getSource(sourceId);
                if (src?.setData) src.setData(scaled);
              } catch {}
            }
            didFit = true;
          }
        }
        if (!loadedFloorsRef.current) loadedFloorsRef.current = {};
        loadedFloorsRef.current[sourceId] = { ...(loadedFloorsRef.current[sourceId] || {}), didFit };
      } catch {}

      // --- Fetch room metadata ---
      const roomsById = await loadRooms(db, universityId, buildingId, floorId);
      const rooms = Object.entries(roomsById).map(([id, data]) => ({ id, ...data }));
      console.log(`Loaded ${rooms.length} room records.`);

      // Hover highlight layer (placed below labels so text remains visible)
      if (!map.getLayer(`${sourceId}-hover`)) {
        const hoverLayer = {
          id: `${sourceId}-hover`,
          type: 'line',
          source: sourceId,
          paint: { 'line-color': '#000', 'line-width': 2.5 },
          filter: ['==', ['id'], '___none___']
        };
        const beforeHover = map.getLayer(`${sourceId}-labels`) ? `${sourceId}-labels` : undefined;
        if (beforeHover) map.addLayer(hoverLayer, beforeHover);
        else map.addLayer(hoverLayer);
      }

      let hoveredId = null;
      const onMouseMove = (e) => {
        const f = e.features?.[0];
        const id = String(f?.id ?? f?.properties?.RevitId ?? '');
        if (id && id !== hoveredId) {
          hoveredId = id;
          try { map.setFilter(`${sourceId}-hover`, ['==', ['id'], id]); } catch {}
          try { map.getCanvas().style.cursor = 'pointer'; } catch {}
        }
      };
      const onMouseLeave = () => {
        hoveredId = null;
        try { map.setFilter(`${sourceId}-hover`, ['==', ['id'], '___none___']); } catch {}
        try { map.getCanvas().style.cursor = ''; } catch {}
      };
      map.on('mousemove', `${sourceId}-fill`, onMouseMove);
      map.on('mouseleave', `${sourceId}-fill`, onMouseLeave);

      // Click behavior: cyan-select + consistent room popup (prefer GeoJSON props)
      const onClick = (e) => {
        const f = e.features?.[0];
        if (!f) return;

        // Toggle selection: clear previous and set current to selected
        try {
          const prevSel = (loadedFloorsRef.current?.[sourceId]?.selectedId);
          if (prevSel != null) {
            map.setFeatureState({ source: sourceId, id: prevSel }, { selected: false });
          }
          const curSel = f.id;
          if (curSel != null) {
            map.setFeatureState({ source: sourceId, id: curSel }, { selected: true });
            if (!loadedFloorsRef.current) loadedFloorsRef.current = {};
            loadedFloorsRef.current[sourceId] = { ...(loadedFloorsRef.current[sourceId] || {}), selectedId: curSel };
          }
        } catch {}

        const { number, roomType, department, areaSF } = f.properties || {};
        const html = `
          <div style="min-width:220px">
            <div><strong>Room #</strong> ${number || '—'}</div>
            <div><strong>Rm Type</strong> ${roomType || '—'}</div>
            <div><strong>Department</strong> ${department || '—'}</div>
            <div><strong>Area</strong> ${areaSF ? `${Number(areaSF).toFixed(2)} SF` : '—'}</div>
          </div>`;

        new mapboxgl.Popup({ closeButton: true, offset: 10 })
          .setLngLat(e.lngLat)
          .setHTML(html)
          .addTo(map);
      };
      map.on('click', `${sourceId}-fill`, onClick);

      // Optional: Color rooms by department using feature-state
      try {
        const applyDeptStyling = () => {
          try {
            const feats = map.querySourceFeatures(sourceId) || [];
            if (!feats.length) return;
            feats.forEach((f) => {
              const id = String(f?.id ?? f?.properties?.RevitId ?? '');
              const dept = roomsById[id]?.department || f?.properties?.Department || null;
              if (id && dept != null) {
                try { map.setFeatureState({ source: sourceId, id }, { dept }); } catch {}
              }
            });
            // Paint expression: cyan when selected, else color by feature-state 'dept'
            const baseDeptExpr = [
              'match', ['feature-state', 'dept'],
              'Facilities/Maintenance', '#90CAF9',
              'ADMIN', '#A5D6A7',
              'EDUCATIONAL', '#F48FB1',
              /* default */ '#FFB300'
            ];
            map.setPaintProperty(`${sourceId}-fill`, 'fill-color', [
              'case', ['boolean', ['feature-state', 'selected'], false],
              '#00E5FF',
              baseDeptExpr
            ]);
            // Outline: thicker + cyan when selected
            map.setPaintProperty(`${sourceId}-outline`, 'line-color', [
              'case', ['boolean', ['feature-state', 'selected'], false],
              '#00E5FF',
              '#5f4635'
            ]);
            map.setPaintProperty(`${sourceId}-outline`, 'line-width', [
              'case', ['boolean', ['feature-state', 'selected'], false],
              2.75, 1
            ]);
          } catch {}
        };
        // Try once after the map idles to ensure features are present
        map.once('idle', applyDeptStyling);
      } catch {}

      // Keep reference for cleanup on reload (preserve didFit flag if any)
      if (!loadedFloorsRef.current) loadedFloorsRef.current = {};
      loadedFloorsRef.current[sourceId] = {
        ...(loadedFloorsRef.current[sourceId] || {}),
        onClick, onMouseMove, onMouseLeave,
        loadedAt: Date.now()
      };

      // Track in state (optional list of loaded floor layers)
      setLoadedFloors((prev) => Array.from(new Set([...(prev || []), sourceId])));
    } catch (err) {
      console.error('Failed to load floor data:', err);
    }
  };

  // ---------- Clear helpers ----------
  const clearCollection = useCallback(async (collectionRef, name, stateSetter) => {
    if (!window.confirm(`Delete all ${name} for ${universityId}? This cannot be undone.`)) return;
    stateSetter([]);
    const batch = writeBatch(db);
    const snapshot = await getDocs(collectionRef);
    snapshot.forEach((d) => batch.delete(d.ref));
    await batch.commit();
  }, [universityId]);

  const clearMarkers = () => clearCollection(markersCollection, 'markers', setMarkers);
  // Paths clearing removed
  const clearConditions = () => clearCollection(conditionsCollection, 'building conditions', setBuildingConditions);

  // ---------- Export ----------
  const exportData = useCallback(() => {
    if (
      markers.length === 0 &&
      Object.keys(buildingConditions).length === 0 &&
      Object.keys(buildingAssessments).length === 0
    ) {
      alert('No data to export.');
      return;
    }

    const bufferDistanceInMeters = 5;
    const buildingFeatures = config?.buildings?.features || [];
    const bufferedBuildings = buildingFeatures.map((f) => {
      const buffered = turf.buffer(f, bufferDistanceInMeters, { units: 'meters' });
      return { id: f.properties.id, geometry: buffered.geometry };
    });

    const outdoorFeatures = Array.isArray(outdoorDataRef.current?.features) ? outdoorDataRef.current.features : [];

    const escapeCsvField = (field) => `"${String(field ?? '').replace(/"/g, '""')}"`;
    const rows = [];

    // Technical assessments
    rows.push(['DataType', 'BuildingID', 'Category', 'SubCategory', 'Score', 'Notes'].join(','));
    Object.entries(buildingAssessments).forEach(([buildingId, assessment]) => {
      const notes = assessment.notes || '';
      if (assessment.scores) {
        Object.entries(assessment.scores).forEach(([category, subScores]) => {
          Object.entries(subScores).forEach(([subCategory, score]) => {
            rows.push([
              escapeCsvField('TechnicalAssessment'),
              escapeCsvField(assessment.buildingName || buildingId),
              escapeCsvField(category),
              escapeCsvField(subCategory),
              escapeCsvField(score),
              escapeCsvField(notes)
            ].join(','));
          });
        });
      }
    });

    rows.push([]);

    // Markers
    rows.push(['DataType', 'Container', 'ID', 'Type', 'Persona', 'Latitude', 'Longitude', 'Comment'].join(','));
    markers.forEach((m) => {
      const [lon, lat] = m.coordinates;
      const markerPoint = turf.point([lon, lat]);
      let foundContainer = '';

      for (const b of bufferedBuildings) {
        try {
          if (turf.booleanPointInPolygon(markerPoint, b.geometry)) { foundContainer = b.id; break; }
        } catch {}
      }

      if (!foundContainer && outdoorFeatures.length) {
        for (const f of outdoorFeatures) {
          try {
            if (!f?.geometry) continue;
            if (turf.booleanPointInPolygon(markerPoint, f)) {
              const name = f.properties?.name || f.properties?.Name || f.properties?.id || 'Outdoor';
              foundContainer = `Outdoor: ${name}`;
              break;
            }
          } catch {}
        }
      }

      rows.push([
        escapeCsvField('Marker'),
        escapeCsvField(foundContainer),
        escapeCsvField(m.id),
        escapeCsvField(m.type),
        escapeCsvField(m.persona),
        escapeCsvField(lat),
        escapeCsvField(lon),
        escapeCsvField(m.comment)
      ].join(','));
    });

    // Stakeholder conditions
    Object.entries(buildingConditions).forEach(([id, condition]) => {
      if (condition) {
        rows.push([
          escapeCsvField('StakeholderCondition'),
          escapeCsvField(id),
          '',
          escapeCsvField(condition),
          '', '', '', '', ''
        ].join(','));
      }
    });

    // Outdoor listing
    rows.push([]);
    rows.push(['DataType', 'OutdoorID', 'Name', 'RawPropsJSON', 'GeometryJSON'].join(','));
    outdoorFeatures.forEach((f, i) => {
      const name = f?.properties?.name || f?.properties?.id || `Outdoor_${i + 1}`;
      rows.push([
        escapeCsvField('OutdoorSpace'),
        escapeCsvField(String(i + 1)),
        escapeCsvField(String(name)),
        escapeCsvField(JSON.stringify(f?.properties || {})),
        escapeCsvField(JSON.stringify(f?.geometry || {}))
      ].join(','));
    });

    const csvContent = rows.join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${universityId}-map-data-export-${new Date().toISOString().slice(0, 10)}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }, [markers, buildingConditions, buildingAssessments, universityId, config]);

  // ---------- Export drawing entries ----------
  const exportDrawingEntries = useCallback(async () => {
    try {
      const snapshot = await getDocs(drawingEntriesCollection);
      if (snapshot.empty) {
        alert('No drawing entries to export.');
        return;
      }
      const rows = [['Email', 'SubmittedAt'].join(',')];
      snapshot.forEach((d) => {
        const data = d.data();
        const email = data.email || '';
        const date = data.submittedAt ? data.submittedAt.toDate().toLocaleString() : 'N/A';
        rows.push([`${email}`, `${date}`].join(','));
      });
      const csvContent = rows.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `${universityId}-drawing-entries-${new Date().toISOString().slice(0, 10)}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (err) {
      console.error('Failed to export drawing entries:', err);
      alert('Error exporting drawing entries. See console.');
    }
  }, [drawingEntriesCollection, universityId]);

  // ---------- Auth buttons ----------
  async function handleAdminSignIn() {
    const auth = getAuth();
    const provider = new GoogleAuthProvider();
    try {
      await signInWithPopup(auth, provider);
    } catch {
      await signInWithRedirect(auth, provider);
    }
  }
  function handleAdminSignOut() { signOut(getAuth()); }

  if (!config) return <div>Loading Map Configuration...</div>;

  return (
    <div className="map-page-container">
      {/* Height chain wrappers to ensure container gets height */}
      <div className="page">
        <div className="map-wrapper">
          {/* Ensure non-zero size to avoid Mapbox init crashes (see CSS .map-container) */}
          <div ref={mapContainerRef} className="map-container" />
        </div>
      </div>

      {mode === 'admin' && (
        <button className="controls-toggle-button" onClick={() => setIsControlsVisible(v => !v)}>
          {isControlsVisible ? 'Hide Controls' : 'Show Controls'}
        </button>
      )}

      <div className="logo-panel-right">
        <div className="logo-box">
          <div className="mapfluence-title">MAPFLUENCE</div>
          <img src={`${BASE}Clark_Enersen_Logo.png`} alt="Clark & Enersen Logo" />
        </div>
        <div className="logo-box">
          <img className="corner-brand" src={`${BASE}HC_image.png`} alt="Hastings College" />
        </div>
      </div>

      {showHelp && (
        <div className="help-panel">
          <button className="close-button" onClick={() => setShowHelp(false)}>X</button>
          <h4>How to Use This Map</h4>
          <ul>
            <li>Click on the map to add a marker.</li>
            {mode === 'admin' && (<>
              <li>Click on a building to select and update its condition.</li>
              <li>Use the controls to toggle markers.</li>
            </>)}
          </ul>
          <button className="close-button-main" onClick={() => setShowHelp(false)}>Close</button>
        </div>
      )}

      {mode === 'admin' && (<>
        {selectedBuildingId && !isTechnicalPanelOpen && panelAnchor && (
          <div
            className="floating-panel"
            style={{
              position: 'absolute', zIndex: 10,
              left: Math.max(8, Math.min(panelAnchor.x + 12, (mapContainerRef.current?.clientWidth || 1000) - 360)),
              top: Math.max(8, Math.min(panelAnchor.y + 12, (mapContainerRef.current?.clientHeight || 800) - 260)),
              width: 340
            }}
          >
            <BuildingInteractionPanel
              buildingId={selectedBuildingId}
              buildingName={config?.buildings?.features?.find(f => f.properties.id === selectedBuildingId)?.properties?.name}
              currentCondition={buildingConditions[selectedBuildingId]}
              onSave={handleConditionSave}
              onOpenTechnical={() => setIsTechnicalPanelOpen(true)}
              onClose={() => {
                setSelectedBuildingId(null);
                setIsTechnicalPanelOpen(false);
                setPanelAnchor(null);
              }}
              canWrite={isAdminUser}
            />
          </div>
        )}

        {selectedBuildingId && isTechnicalPanelOpen && (
          <AssessmentPanel
            buildingId={selectedBuildingId}
            assessments={buildingAssessments}
            universityId={universityId}
            panelPos={panelAnchor}
            isAdminRole={isAdminUser}
            onClose={() => setIsTechnicalPanelOpen(false)}
            onSave={handleAssessmentSave}
          />
        )}
      </>)}

              </div>
            )}

            {mode === 'admin' && (
              <div className="control-section theme-selector">
                <label htmlFor="theme-select">Map View:</label>
                <select id="theme-select" value={mapTheme} onChange={(e) => setMapTheme(e.target.value)}>
                  <option value="stakeholder">Stakeholder Condition</option>
                  <option value="progress">Assessment Progress</option>
                </select>
              </div>
            )}

            {mode === 'admin' && (
              <div className="control-section data-filters">
                <h4>Data Filters</h4>
                <div className="filter-row">
                  <label>
                    <input type="checkbox" checked={showStudentMarkers} onChange={() => setShowStudentMarkers(v => !v)} /> Student Markers
                  </label>
                  <button className="btn" onClick={() => setShowStudentMarkers(v => !v)}>
                    {showStudentMarkers ? 'Hide' : 'Show'}
                  </button>
                </div>
                <div className="filter-row">
                  <label>
                    <input type="checkbox" checked={showStaffMarkers} onChange={() => setShowStaffMarkers(v => !v)} /> Staff Markers
                  </label>
                  <button className="btn" onClick={() => setShowStaffMarkers(v => !v)}>
                    {showStaffMarkers ? 'Hide Staff' : 'Show Staff'}
                  </button>
                </div>
              </div>
            )}

            <div className="mode-selector">
              <button className={interactionMode === 'select' ? 'active' : ''} onClick={() => setInteractionMode('select')}>
                Select/Marker
              </button>
            </div>

            <div className="button-row">
              {mode === 'admin' && (
                <button onClick={() => setShowMarkers((s) => !s)}>
                  {showMarkers ? `Hide Markers (${filteredMarkers.length})` : `Show Markers (${filteredMarkers.length})`}
                </button>
              )}
              {/* Paths controls removed */}
            </div>

            {mode === 'admin' && (
              <div className="control-section admin-controls">
                <div className="actions">
                  <button className="btn span-2" onClick={exportData}>Export Map Data</button>
                  {config.enableDrawingEntry && (
                    <button className="btn span-2" onClick={exportDrawingEntries}>Export Drawing Entries</button>
                  )}
                  <button className="btn" onClick={clearMarkers}>Clear Markers</button>
                  <button className="btn span-2" onClick={clearConditions}>Clear Conditions</button>
                </div>

                <div className="control-section">
                  <h4 style={{marginTop:10}}>Floorplans</h4>
                  <div className="floorplans">
                    <select id="fp-building" value={selectedBuilding} onChange={e => onBuildingChange(e.target.value)}>
                      {Object.keys(FLOORPLANS).map(name => (
                        <option key={name} value={name}>{name}</option>
                      ))}
                    </select>
                    <select id="fp-floor" value={selectedFloor} onChange={e => setSelectedFloor(e.target.value)}>
                      {Object.keys(FLOORPLANS[selectedBuilding] ?? {}).map(fl => (
                        <option key={fl} value={fl}>{fl}</option>
                      ))}
                    </select>
                    <button id="fp-load" className="btn" onClick={handleLoadFloorplan} disabled={!selectedBuilding || !selectedFloor}>
                      Load Floorplan
                    </button>
                  </div>

                  {/* Affine transform tuner for static floorplans */}
                  <div className="floor-transform" style={{marginTop: 10, borderTop: '1px solid #eee', paddingTop: 10}}>
                    <div style={{display:'flex', gap:8, flexWrap:'wrap'}}>
                      <label style={{display:'flex', flexDirection:'column', fontSize:12}}>
                        tx
                        <input
                          type="number" step="0.000001"
                          value={Number.isFinite(affineDraft.tx)?affineDraft.tx:''}
                          onChange={e=>setAffineDraft(d=>({ ...d, tx: parseFloat(e.target.value) }))}
                          style={{width:120}}
                        />
                      </label>
                      <label style={{display:'flex', flexDirection:'column', fontSize:12}}>
                        ty
                        <input
                          type="number" step="0.000001"
                          value={Number.isFinite(affineDraft.ty)?affineDraft.ty:''}
                          onChange={e=>setAffineDraft(d=>({ ...d, ty: parseFloat(e.target.value) }))}
                          style={{width:120}}
                        />
                      </label>
                      <label style={{display:'flex', flexDirection:'column', fontSize:12}}>
                        scale
                        <input
                          type="number" step="0.0000001"
                          value={Number.isFinite(affineDraft.scale)?affineDraft.scale:''}
                          onChange={e=>setAffineDraft(d=>({ ...d, scale: parseFloat(e.target.value) }))}
                          style={{width:120}}
                        />
                      </label>
                      <label style={{display:'flex', flexDirection:'column', fontSize:12}}>
                        angleDeg
                        <input
                          type="number" step="0.1"
                          value={Number.isFinite(affineDraft.angleDeg)?affineDraft.angleDeg:''}
                          onChange={e=>setAffineDraft(d=>({ ...d, angleDeg: parseFloat(e.target.value) }))}
                          style={{width:120}}
                        />
                      </label>
                      <label style={{display:'flex', flexDirection:'column', fontSize:12}}>
                        px
                        <input
                          type="number" step="0.000001"
                          value={Number.isFinite(affineDraft.px)?affineDraft.px:''}
                          onChange={e=>setAffineDraft(d=>({ ...d, px: parseFloat(e.target.value) }))}
                          style={{width:120}}
                        />
                      </label>
                      <label style={{display:'flex', flexDirection:'column', fontSize:12}}>
                        py
                        <input
                          type="number" step="0.000001"
                          value={Number.isFinite(affineDraft.py)?affineDraft.py:''}
                          onChange={e=>setAffineDraft(d=>({ ...d, py: parseFloat(e.target.value) }))}
                          style={{width:120}}
                        />
                      </label>
                    </div>

                    <div style={{display:'flex', gap:8, marginTop:8, flexWrap:'wrap'}}>
                      <button
                        className="btn"
                        onClick={async ()=>{
                          const b = selectedBuilding, f = selectedFloor;
                          setAffineOverrides(prev=>({ ...(prev||{}), [b]: { ...(prev?.[b]||{}), [f]: { ...affineDraft } } }));
                          try {
                            const lastSel = floorSelectionRef.current?.[floorUrl];
                            await loadFloorGeojson(mapRef.current, floorUrl, lastSel, { ...affineDraft });
                          } catch {}
                        }}
                      >Apply</button>

                      <button
                        className="btn"
                        onClick={async ()=>{
                          const b = selectedBuilding, f = selectedFloor;
                          setAffineOverrides(prev=>{
                            const next = { ...(prev||{}) };
                            if (next[b]) {
                              delete next[b][f];
                              if (Object.keys(next[b]).length===0) delete next[b];
                            }
                            return next;
                          });
                          try {
                            const lastSel = floorSelectionRef.current?.[floorUrl];
                            const base = (config?.floorplanAffine?.[selectedBuilding]?.[selectedFloor])
                              || (config?.floorplanAffine?.[BUILDING_ALIAS[selectedBuilding]]?.[selectedFloor]);
                            await loadFloorGeojson(mapRef.current, floorUrl, lastSel, base);
                          } catch {}
                        }}
                      >Reset</button>

                      <button
                        className="btn"
                        onClick={async ()=>{
                          try {
                            const center = mapRef.current?.getCenter();
                            if (center) setAffineDraft(d=>({ ...d, px: center.lng, py: center.lat }));
                          } catch {}
                        }}
                      >Pivot = Map Center</button>

                      <button
                        className="btn"
                        onClick={()=>{
                          const snippet = JSON.stringify({
                            floorplanAffine: { [selectedBuilding]: { [selectedFloor]: { ...affineDraft } } }
                          }, null, 2);
                          try {
                            navigator.clipboard?.writeText(snippet);
                            alert('Copied JSON to clipboard');
                          } catch {
                            const ta = document.createElement('textarea');
                            ta.value = snippet;
                            document.body.appendChild(ta);
                            ta.select();
                            document.execCommand('copy');
                            document.body.removeChild(ta);
                            alert('Copied JSON to clipboard');
                          }
                        }}
                      >Copy JSON</button>
                    </div>

                    {/* Nudge mode */}
                    <div style={{display:'flex', gap:8, alignItems:'center', marginTop:8, flexWrap:'wrap'}}>
                      <label style={{display:'flex', alignItems:'center', gap:6}}>
                        <input type="checkbox" onChange={e=> setNudgeEnabled(e.target.checked)} checked={nudgeEnabled || false} />
                        Nudge Mode (arrow keys)
                      </label>
                      <label style={{display:'flex', alignItems:'center', gap:6}}>
                        move step
                        <input type="number" step="0.000001" value={nudgeStep} onChange={e=> setNudgeStep(parseFloat(e.target.value) || 0)} style={{width:100}} />
                      </label>
                      <label style={{display:'flex', alignItems:'center', gap:6}}>
                        rot step
                        <input type="number" step="0.1" value={rotStep} onChange={e=> setRotStep(parseFloat(e.target.value) || 0)} style={{width:100}} />
                      </label>
                      <label style={{display:'flex', alignItems:'center', gap:6}}>
                        scale step (×)
                        <input type="number" step="0.001" min="1.001" value={scaleStep} onChange={e=> setScaleStep(parseFloat(e.target.value) || 1.01)} style={{width:100}} />
                      </label>
                      <span style={{fontSize:12,color:'#666'}}>Arrow keys move; [ ] rotate. Shift=10×, Alt=0.1×</span>
                    </div>

                    {/* Pivot pick helpers */}
                    <div style={{display:'flex', gap:8, alignItems:'center', marginTop:8, flexWrap:'wrap'}}>
                      <button className="btn" onClick={startPivotPick} disabled={pivotPickActiveRef.current}>Pivot = Map Click</button>
                      <button className="btn" onClick={cancelPivotPick} disabled={!pivotPickActiveRef.current}>Cancel</button>
                      <button className="btn" onClick={setPivotToSelectedCentroid} disabled={!selectedBuildingId}>Pivot = Building Centroid</button>
                      <label style={{display:'flex', alignItems:'center', gap:6}}>
                        fit margin
                        <input type="number" step="0.01" min="0.5" max="1.0" value={fitMargin} onChange={e=> setFitMargin(parseFloat(e.target.value) || 1)} style={{width:80}} />
                      </label>
                      <button className="btn" onClick={snapScaleToBuilding}>Snap Scale to Building</button>
                      <button className="btn" onClick={snapTranslateToBuildingCentroid}>Snap Translate to Centroid</button>
                      <button className="btn" onClick={fitAndCenterToBuilding}>Fit + Center</button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default StakeholderMap;

